syntax = "proto3";

/*
Read request = Client sends only msgId(see ReadRequest) and server will reply with full message answer.
Write request = Client send full message and server process it, and reply if message type need that.

Client must send TaskStatus + TaskExit messages before exit.
If server wants gracefully shutdown it must reply with GetState.bStop = True and wait for clients TaskStatus/TaskExit.
If there is no time for that, server must close pipe/socket and after client detect broken pipe/connection it must stop.
*/

message Request {                         //This client sends this to get data from server.
  enum msgClass {
    INIT_TASK = 0;
    TASK_STATUS = 1;
    TASK_EXIT = 2;
    GET_STATE = 3;
    LOG = 4;
    GET_FILE_CONTENT = 5;
    SELECT = 6;
  }
  msgClass Class = 1;
}

message InitTask {                        //Reply from server for request with msgId = 1.
  int32 msgId = 1;                        //InitTask.msgId = 0
  string AppPath = 2;                     //Path to target app directory, to be executed.
  repeated string args = 6;               //Optional arguments to pass to target python app's module.
  message ConfigOptions {
    int32 LogLvl = 1;                     //0-4 , level logs from NC documentation.
    string DataFolder = 2;                //Path to NC data folder.
  }
  ConfigOptions config = 7;
}

message TaskStatus {                      //Write request to set Task Status. No reply.
  int32 msgId = 1;                        //TaskStatus.msgId = 1
  int32 Status = 2;                       //Status of task.
  string ErrDescription = 8;              //Optional error, if any. Valid only when Status is non success.
}

message TaskExit {                        //Write request. No reply. Server must close pipe/socket after this message.
  int32 msgId = 1;                        //TaskExit.msgId = 2
  string msgText = 8;                     //Optional text, for exit action. Ignored in most cases.
}

message GetState {                        //Reply from server for request with msgId = 5. Client send it every 10 sec.
  int32 msgId = 1;                        //GetState.msgId = 3
  bool bStop = 2;                         //If true client must gracefully stop it's work.
  //? Something else?
}

message Log {                             //Write request. No reply.
  int32 msgId = 1;                        //Log.msgId = 4
  int32 flags = 2;                        //Reserved.
  string sModule = 3;                     //What module logs belongs to.
  repeated string Content = 4;            //One or more strings to put to log.
}

message GetFileContent {                  //Read\Write request for file.
  int32 msgId = 1;                        //GetFileContent.msgId = 5
  string UserID = 2;
  string FileId = 3;
  int64 ResultCode = 4;                   //Present only in reply from server.
  bytes FileContent = 5;                  //Present only in reply from server and if ResultCode is success.
}

message Select {
  int32 msgId = 1;                        //Select.msgId = 6
  repeated string what = 2;               //aliases or filed names.
  string from = 3;
  string from_alias = 4;
  message JoinType {
    string name = 1;                      //join, innerJoin, leftJoin, rightJoin.
    string fromAlias = 2;
    string join = 3;
    string alias = 4;
    string condition = 5;
  }
  repeated JoinType joins = 5;
  message WhereExpr {
    string type = 1;                       //where, andWhere, orWhere
    string expression = 2;
  }
  repeated WhereExpr whereas = 6;
  repeated string GroupBy = 7;
  message HavingExpr {
    string type = 1;                       //having, andHaving, orHaving
    string expression = 2;
  }
  repeated HavingExpr havings = 8;
  repeated string OrderBy = 9;
}


