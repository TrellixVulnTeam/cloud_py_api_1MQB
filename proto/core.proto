syntax = "proto3";

/*
All communications messages send by client, server only reply on them.

Client must send TaskStatus + TaskExit messages before exit.
Gracefully shutdown: server reply with TASK_GET_STATE.bStop = True and wait for clients TaskStatus/TaskExit.
Immediately shutdown: server closes pipe/sock.
Remark: Both client and server part, must stop work after communication channel become broken.
*/

enum msgClass {
    RESERVED = 0;
    TASK_INIT = 1;
    TASK_STATUS = 2;
    TASK_EXIT = 3;
    TASK_GET_STATE = 4;
    TASK_LOG = 5;
    OPEN_CHANNEL = 6;                     //Reserved for future addon for multithreading requests.
    FS_LIST = 7;                          //getDirectoryListing
    FS_GET_INFO = 8;                      //FileInfo ?
    FS_READ = 9;
    FS_CREATE = 10;
    FS_WRITE = 11;
    FS_DELETE = 12;
    FS_MOVE = 13;                         //rmvOriginal flag something like -> copyFromStorage
    DB_SELECT = 14;
    DB_CURSOR = 15;
    DB_EXEC = 16;                         //Insert/Update/Delete
}

/* docs.nextcloud.com/server/latest/admin_manual/configuration_server/logging_configuration.html#log-level */
enum logLvl {
    DEBUG = 0;
    INFO = 1;
    WARN = 2;
    ERROR = 3;
    FATAL = 4;
}

message Request {                         //Client sends this to server.
  msgClass classId = 1;
}

message TaskInitReply {
  msgClass classId = 1;                   //msgClass.TASK_INIT
  string appPath = 2;                     //Path to target app directory, to be executed.
  repeated string args = 6;               //Optional arguments to pass to target python app's module.
  message cfgOptions {
    logLvl log_lvl = 1;                   //0-4 , level logs from NC documentation.
    string dataFolder = 2;                //Path to NC data folder.
  }
  cfgOptions config = 7;
}

enum taskStatus {
    ST_SUCCESS = 0;
    ST_IN_PROGRESS = 1;                   //pyfrm init done, running target app
    ST_INIT_ERROR = 2;                    //pyfrm cannot init target app
    ST_EXCEPTION = 3;                     //unexpected exception occurred
    ST_ERROR = 4;                         //target app return error status
    ST_UNKNOWN = 5;                       //default task state at start
}

message TaskStatus {                      //No reply.
  msgClass classId = 1;                   //TaskStatus.TASK_STATUS
  taskStatus st_code = 2;                 //Status code of a task.
  string error = 3;                       //Optional error, if any. Valid only when Status is non success/in_progress.
}

message TaskExit {                        //No reply. Server must close pipe/socket after this message.
  msgClass classId = 1;                   //msgClass.TASK_EXIT
  string msgText = 2;                     //Optional text, for exit action. Ignored in most cases.
}

message TaskGetStateReply {               //Reply for TASK_GET_STATE. Client send it every ~5 sec.
  msgClass classId = 1;                   //msgClass.TASK_GET_STATE
  bool bStop = 2;                         //If true client must gracefully stop it's work.
}

message TaskLog {                         //No reply.
  msgClass classId = 1;                   //msgClass.TASK_LOG
  logLvl log_lvl = 2;
  string sModule = 3;                     //What module logs belongs to.
  repeated string content = 4;            //One or more strings to put to log.
}

message OpenChannel {                     //Request from client to open additional communication channel.
  msgClass classId = 1;                   //msgClass.OPEN_CHANNEL
  //Not Implemented.
}

message OpenChannelReply {                //Reply to client on request to open channel.
  msgClass classId = 1;                   //msgClass.OPEN_CHANNEL
  //Not Implemented.
}

/* FS messages start */

enum fsResultCode {
    NO_ERROR = 0;
    NOT_PERMITTED = 1;
    LOCKED = 2;
    NOT_FOUND = 3;
    IO_ERROR = 4;
}

message FsList {
  msgClass classId = 1;                   //msgClass.FS_LIST
  //TODO
}

message FsListReply {
  msgClass classId = 1;                   //msgClass.FS_LIST
  //TODO
}

message FsGetInfo {
  msgClass classId = 1;                   //msgClass.FS_GET_INFO
  //TODO
}

message FsGetInfoReply {
  msgClass classId = 1;                   //msgClass.FS_GET_INFO
  //TODO
}

message FsRead {
  msgClass classId = 1;                   //msgClass.FS_READ
  string userID = 2;
  string fileID = 3;
}

message FsReadReply {
  msgClass classId = 1;                   //msgClass.FS_READ
  fsResultCode resCode = 2;
  bool bNotLast = 3;                      //If answer don't fit in one reply, this will be True.
  bytes fileContent = 4;                  //Present only if resCode is NO_ERROR.
}

message FsCreate {                        //Reply for this is a FsReply message.
  msgClass classId = 1;                   //msgClass.FS_CREATE
  //TODO
}

message FsWrite {                         //Reply for this is a FsReply message.
  msgClass classId = 1;                   //msgClass.FS_WRITE
  //TODO
}

message FsDelete {                        //Reply for this is a FsReply message.
  msgClass classId = 1;                   //msgClass.FS_DELETE
  //TODO
}

message FsMove {                          //Reply for this is a FsReply message.
  msgClass classId = 1;                   //msgClass.FS_MOVE
  //TODO
}

message FsReply {
  msgClass classId = 1;                   //msgClass.(FS_CREATE || FS_WRITE || FS_DELETE || FS_MOVE)
  fsResultCode resCode = 2;
}

/* FS messages end */

/* DB messages start */

message whereExpr {                       //struct for `where` part.
  string type = 1;                        //where, andWhere, orWhere
  string expression = 2;
}

message DbSelect {
  msgClass classId = 1;                   //msgClass.DB_SELECT
  repeated string what = 2;               //aliases or filed names.
  string from = 3;
  string fromAlias = 4;
  message joinType {
    string name = 1;                      //join, innerJoin, leftJoin, rightJoin.
    string fromAlias = 2;
    string join = 3;
    string alias = 4;
    string condition = 5;
  }
  repeated joinType joins = 5;
  repeated whereExpr whereas = 6;
  repeated string groupBy = 7;
  message havingExpr {
    string type = 1;                       //having, andHaving, orHaving
    string expression = 2;
  }
  repeated havingExpr havings = 8;
  repeated string orderBy = 9;
  int64 maxResults = 10;
  int64 firstResult = 11;
}

message DbSelectReply {
  msgClass classId = 1;                     //msgClass.DB_SELECT
  int64 rowCount = 2;
  string error = 3;
  int64 handle = 4;                         //valid if only rowcount > 0.
}

enum dbCursorCmd {
    FETCH = 0;
    FETCH_ALL = 1;
    CLOSE = 2;
}

message DbCursor {
  msgClass classId = 1;                     //msgClass.DB_CURSOR
  int64 handle = 2;
  dbCursorCmd cmd = 3;
}

message DbCursorReply {
  msgClass classId = 1;                     //msgClass.DB_CURSOR
  string error = 2;
  repeated string columnsName = 3;
  message columnData {
    bool bPresent = 1;                      //if result is NULL for that column raw, then this is True.
    bytes data = 2;                         //present if result fir column raw is not NULL.
  }
  repeated columnData columnsData = 4;
}

enum dbExecType {
    INSERT = 0;
    UPDATE = 1;
    DELETE = 2;
}

message DbExec {
  msgClass classId = 1;                     //msgClass.DB_EXEC
  dbExecType type = 2;
  repeated string what = 3;                 //aliases or filed names.
  //TODO: values
  repeated whereExpr whereas = 6;
}

message DbExecReply {
  msgClass classId = 1;                     //msgClass.DB_EXEC
  int64 nAffectedRows = 2;
  string error = 3;
}

/* DB messages end */
