syntax = "proto3";

/*
Read request = Client sends only msgClass(see Request) and server will reply with full message answer.
Write request = Client send full message and server process it, and reply if message type need that.

Client must send TaskStatus + TaskExit messages before exit.
If server wants gracefully shutdown it must reply with GetState.bStop = True and wait for clients TaskStatus/TaskExit.
If there is no time for that, server must close pipe/socket and after client detect broken pipe/connection it must stop.
*/

enum msgClass {
    RESERVED = 0;
    INIT_TASK = 1;
    TASK_STATUS = 2;
    TASK_EXIT = 3;
    GET_STATE = 4;
    OPEN_CHANNEL = 5;                     //Reserved for future addon for multithreading requests.
    LOG = 6;
    GET_FILE_INFO = 7;                    //FileInfo ?
    READ_FILE = 8;
    CREATE_FILE = 9;
    WRITE_FILE = 10;
    DELETE_FILE = 11;
    MOVE_FILE = 12;                       //rmvOriginal flag something like -> copyFromStorage
    GET_DIR_LISTING = 13;                 //getDirectoryListing
    SELECT = 14;
    CURSOR = 15;
    EXEC_STATEMENT = 16;                  //Insert/Update/Delete
    EXEC_STATEMENT_REPLY = 17;
}

/* docs.nextcloud.com/server/latest/admin_manual/configuration_server/logging_configuration.html#log-level */
enum logLvl {
    DEBUG = 0;
    INFO = 1;
    WARN = 2;
    ERROR = 3;
    FATAL = 4;
}

message Request {                         //This client sends this to get data from server.
  msgClass classId = 1;
}

message InitTask {                        //Reply from server for request with msgId = 1.
  msgClass classId = 1;                   //msgClass.INIT_TASK
  string appPath = 2;                     //Path to target app directory, to be executed.
  repeated string args = 6;               //Optional arguments to pass to target python app's module.
  message ConfigOptions {
    logLvl log_lvl = 1;                   //0-4 , level logs from NC documentation.
    string dataFolder = 2;                //Path to NC data folder.
  }
  ConfigOptions config = 7;
}

enum taskStatus {
    ST_SUCCESS = 0;
    ST_IN_PROGRESS = 1;                   //pyfrm init done, running target app
    ST_INIT_ERROR = 2;                    //pyfrm cannot init target app
    ST_EXCEPTION = 3;                     //unexpected exception occurred
    ST_ERROR = 4;                         //target app return error status
    ST_UNKNOWN = 5;                       //default task state at start
}

message TaskStatus {                      //Write request to set Task Status. No reply.
  msgClass classId = 1;                   //TaskStatus.TASK_STATUS
  taskStatus st_code = 2;                 //Status code of a task.
  string errDescription = 8;              //Optional error, if any. Valid only when Status is non success/in_progress.
}

message TaskExit {                        //Write request. No reply. Server must close pipe/socket after this message.
  msgClass classId = 1;                   //msgClass.TASK_EXIT
  string msgText = 8;                     //Optional text, for exit action. Ignored in most cases.
}

message GetState {                        //Reply from server for request of state. Client send it every 5 sec.
  msgClass classId = 1;                   //msgClass.GET_STATE
  bool bStop = 2;                         //If true client must gracefully stop it's work.
}

message OpenChannel {                     //Request from client to open additional communication channel.
  msgClass classId = 1;                   //msgClass.OPEN_CHANNEL
  //Not Implemented.
}

message Log {                             //Write request. No reply.
  msgClass classId = 1;                   //msgClass.LOG
  logLvl log_lvl = 2;
  string sModule = 3;                     //What module logs belongs to.
  repeated string content = 4;            //One or more strings to put to log.
}

/* FS messages start */

enum FsResultCode {
    NO_ERROR = 0;
    NOT_PERMITTED = 1;
    LOCKED = 2;
    NOT_FOUND = 3;
    IO_ERROR = 4;
}

message GetFileContent {                  //Read\Write request for file.
  msgClass classId = 1;                   //msgClass.GET_FILE_CONTENT
  string userID = 2;
  string fileID = 3;
  FsResultCode resCode = 4;               //Present only in reply from server.
  bytes fileContent = 5;                  //Present only in reply from server and if ResultCode is success.
}

/* FS messages end */

/* DB messages start */

message Select {                          //Reply for this message -> SelectResult
  msgClass classId = 1;                   //msgClass.SELECT
  repeated string what = 2;               //aliases or filed names.
  string from = 3;
  string fromAlias = 4;
  message JoinType {
    string name = 1;                      //join, innerJoin, leftJoin, rightJoin.
    string fromAlias = 2;
    string join = 3;
    string alias = 4;
    string condition = 5;
  }
  repeated JoinType joins = 5;
  message WhereExpr {
    string type = 1;                       //where, andWhere, orWhere
    string expression = 2;
  }
  repeated WhereExpr whereas = 6;
  repeated string groupBy = 7;
  message HavingExpr {
    string type = 1;                       //having, andHaving, orHaving
    string expression = 2;
  }
  repeated HavingExpr havings = 8;
  repeated string orderBy = 9;
  int64 maxResults = 10;
  int64 firstResult = 11;
}

message SelectResult {
  msgClass classId = 1;                     //msgClass.SELECT
  int64 rowCount = 2;
  string error = 3;
  int64 handle = 4;                         //valid if only rowcount > 0.
}

enum CursorCmd {
    FETCH = 0;
    FETCH_ALL = 1;
    CLOSE = 2;
}

message Cursor {
  msgClass classId = 1;                     //msgClass.CURSOR
  int64 handle = 2;
  CursorCmd cmd = 3;
  string error = 4;
  repeated string columnName = 5;           //present only in reply
  repeated bytes columnData = 6;            //present only in reply
}

enum ExecuteDbType {
    INSERT = 0;
    UPDATE = 1;
    DELETE = 2;
}

message ExecuteStatement {
  msgClass classId = 1;                     //msgClass.EXEC_STATEMENT
  ExecuteDbType type = 2;
  //TODO
}

message ExecuteStatementReply {
  msgClass classId = 1;                     //msgClass.EXEC_STATEMENT_REPLY
  int64 nAffectedRows = 2;
  string error = 3;
}

/* DB messages end */
